#!/usr/bin/env python
# Generate python wrapper from headers.
import re
import sys

def extract_insn(header):
    insns = ['invalid']
    infp = open(header, 'r')
    for line in infp:
        comment = line.find('//')
        if comment >= 0:
            # ignore comments
            line = line[:comment]
        line = line.strip()
        if len(line) == 0 or line.startswith('#'):
            # ignore empty lines and preprocessor defines
            continue
        elif line.startswith('FORMAT'):
            # ignore
            continue
        else:
            _, insn, _ = re.match('^INS(_\d)?\s*\(\s*([\w\d]+)\s*(,.*)?\s*\)$', line).groups()
            insns += [insn]
    insns += ['__count']
    s = ''
    for i in xrange(len(insns)):
        s += 'I%s = %d\n' % (insns[i], i)
    return s

def extract_struct(header):
    def c_to_ctype(typ, const=None, unsigned=None, signed=None, ptr=None, arr=None):
        if typ == 'char':
            if unsigned:
                result = 'c_ubyte'
            else:
                result = 'c_char'
        elif typ == 'short':
            if unsigned:
                result = 'c_ushort'
            else:
                result = 'c_short'
        elif typ == 'int':
            if unsigned:
                result = 'c_uint'
            else:
                result = 'c_int'
        elif typ.endswith('_t'):
            # uint8_t -> c_uint8
            result = 'c_' + typ[:-2]
        else:
            raise Exception('Unhandled type %s' % typ)

        if result == 'c_char' and ptr:
            result = 'c_char_p'
        elif ptr:
            result = 'POINTER(%s)' % result

        if arr:
            size = int(arr[1:-1].strip(), 0)
            result = '%s*%d' % (result, size)

        return result

    fields = []
    in_struct = False

    infp = open(header, 'r')
    for line in infp:
        comment = line.find('//')
        if comment >= 0:
            # ignore comments
            line = line[:comment]
        line = line.strip()
        if len(line) == 0 or line.startswith('#'):
            # ignore empty lines and preprocessor defines
            pass
        elif line.startswith('EXPORT'):
            # ignore exported functions
            pass
        elif line.startswith('typedef struct'):
            in_struct = True
        elif line.startswith('} inst_t'):
            in_struct = False
        elif in_struct:
            try:
                if line.startswith('DEFINE_FIELD'):
                    typ, name = re.match(r'^DEFINE_FIELD\s*\(\s*([^,\s]*)\s*,\s*([^,\s]*)\s*\)$', line).groups()
                    fields += [
                        (name, c_to_ctype(typ)),
                        ('used_%s' % name, 'c_uint8')
                    ]
                elif line.startswith('BEGIN_FIELDS') or line.startswith('END_FIELDS'):
                    # ignore 
                    pass
                else:
                    const, unsigned, signed, typ, ptr, name, arr = re.match(r'^(const)?\s*(unsigned)?(signed)?\s*([\d\w]+)\s*(\*)?\s*([\d\w]+)\s*(\[\s*\d+\s*\])?\s*;$', line).groups()
                    fields += [(name, c_to_ctype(typ, const=const, unsigned=unsigned, ptr=ptr, arr=arr))]
            except AttributeError:
                raise Exception('Bad line: %s' % line)

    s = ''
    s += 'class Inst(Structure):\n'
    s += '    _fields_ = [\n'
    for f in fields:
        s += '        ("%s", %s),\n' % f
    s += '    ]\n'
    return s

TEMPLATE = '''# Autogenerated
from ctypes import *
import platform

if platform.system() == 'Windows':
    if platform.architecture()[0] == '32bit':
        dll = cdll.@@NAME@@_32
    else:
        dll = cdll.@@NAME@@_64
elif platform.system() == 'Darwin':
    dll = cdll.LoadLibrary('lib@@NAME@@.dylib')
else:
    dll = cdll.LoadLibrary('lib@@NAME@@.so')

@@STRUCT@@

@@INSN@@

dll.disassemble.argtypes = [POINTER(Inst), c_uint32, POINTER(c_uint8)]

def disassemble(pc, input):
    inst = Inst()
    if isinstance(input, str):
        input = cast(input, POINTER(c_uint8))
    dll.disassemble(byref(inst), pc, input)
    assert inst._st_size == sizeof(inst)
    return inst

mnemonics = (c_char_p * I__count).in_dll(dll, 'mnemonics')
num_registers = c_uint.in_dll(dll, 'num_registers').value
registers = (c_char_p * num_registers).in_dll(dll, 'registers')
'''

name = sys.argv[1]
output = TEMPLATE
output = output.replace('@@NAME@@', name)
output = output.replace('@@INSN@@', extract_insn('opcodes.h'))
output = output.replace('@@STRUCT@@', extract_struct('%s.h' % name))
outfp = open('py%s.py' % name, 'w')
outfp.write(output)
