from __future__ import print_function
import sys
import StringIO
from string import printable

class DoneReadingException(Exception):
  pass

class error(Exception):
  pass

class ClemencyFile(object):
  def __init__(self, f):
    self.file = f
    self.rpn = 0
    self.rp = 0
    self.wpn = 0
    self.wp = 0
    self.towrite = []

  def _readbyte(self):
    res = self.file.read(1)
    if not res:
      raise DoneReadingException()
    return ord(res)

  def _readnyte(self):
    if self.rpn == 0:
      self.rp = self._readbyte()
      self.rpn = 8

    self.rp = (self.rp << 8) | self._readbyte()
    self.rpn += 8

    out = self.rp >> (self.rpn - 9)
    self.rp &= (1 << (self.rpn - 9)) - 1
    self.rpn -= 9

    return out

  def _readflush(self):
    if self.rp != 0:
      print("WARNING: _readflush flushed %d nonzero bits - your read lengths are wrong" % self.rpn, file=sys.stderr)
    self.rpn = 0
    self.rp = 0

  def _writenyte(self, n):
    self.wp = (self.wp << 9) | n
    self.wpn += 9
    while self.wpn >= 8:
      self.towrite.append((self.wp >> (self.wpn - 8)) & 0xff)
      self.wpn -= 8
    self.wp = self.wp & ((1 << self.wpn) - 1)

  def _writeflush(self):
    self.wp <<= (8 - self.wpn)
    if self.wpn:
        self.towrite.append(self.wp)
    self.file.write(''.join(map(chr, self.towrite)))
    self.file.flush()
    self.towrite = []
    self.wpn = 0
    self.wp = 0

  def read(self, n):
    out = []
    try:
      for _ in xrange(n):
        out.append(self._readnyte())
      self._readflush()
    except BaseException as e:
      print("Read interrupted (%s); partial output:" % e, out)
      raise
    return ClemencyBuffer(out)

  def _normalize_readuntil(self, nval):
    if isinstance(nval, str):
      nval = [ord(c) for c in nval]
    if isinstance(nval, (int, long)):
      nval = [nval]
    return nval

  def readuntil(self, *nvals, **kwargs):
    nvals = [self._normalize_readuntil(nval) for nval in nvals]
    maxsize = kwargs.pop('maxsize', -1)

    out = []
    try:
      while True:
        n = self._readnyte()
        out.append(n)
        if len(out) == maxsize:
          break
        for nval in nvals:
          if out[-len(nval):] == nval:
            break
        else:
          continue
        break
    except BaseException as e:
      print("Read interrupted (%s); partial output:" % e, out)
      raise
    self._readflush()
    return ClemencyBuffer(out)

  def write(self, nytearr):
    if isinstance(nytearr, str):
      nytearr = [ord(c) for c in nytearr]
    for n in nytearr:
      self._writenyte(n)
    self._writeflush()

  def read_all(self):
    output = []
    while True:
      try:
        output.append(self._readnyte())
      except DoneReadingException as e:
        break
    return ClemencyBuffer(output)

  def close(self):
    self.file.close()

class ClemencyBuffer(object):
  '''
  ClemencyBuffer class - meant to represent a range of memory in the Clemency architecture.
  Essentially a wrapper around a list of 9-bit unsigned integers.

  Should provide the standard list access interface (though not `del`), as well as 
  concatenation, multiplication, and conversion to raw bytes that can be sent across the wire.

  There are also some helper functions to deal with printable stuff.
  '''
  def __init__(self, initial_data=None):
    if initial_data is None:
      initial_data = []
    assert all(0 <= b <= 0x1ff for b in initial_data)
    self._buf = initial_data
  def push(self, b):
    assert 0 <= b <= 0x1ff
    self._buf.append(b)
  def add(self, b):
    self.push(b)
  def __getitem__(self, key):
    if isinstance(key, int):
      return self._buf[key]
    elif isinstance(key, slice):
      sl = self._buf[key.start:key.stop:key.step]
      return ClemencyBuffer(sl)
  def __setitem__(self, key, value):
    if isinstance(value, int):
      self._buf[key] = value
    elif isinstance(value, str):
      assert len(value) <= 2
      if len(value) == 1:
        self._buf[key] = ord(value)
      else:
        assert ord(value[0]) in [0, 1]
        self._buf[key] = (ord(value[0]) << 9) | (ord(value[1]))
    else:
      assert False
  def __add__(self, other):
    if isinstance(other, list):
      return ClemencyBuffer(self._buf + other)
    elif isinstance(other, str):
      assert all(c in printable for c in other)
      return self + ClemencyBuffer.from_string(other)
    elif isinstance(other, type(self)):
      return ClemencyBuffer(self._buf + other._buf)
    else:
      assert False
  def __mul__(self, other):
    assert isinstance(other, int)
    return ClemencyBuffer(self._buf * other)
  def __repr__(self):
    return "ClemencyBuffer(%r)" % self._buf
  def __str__(self):
    return self.to_printable_string()
  def raw_string(self):
    io = StringIO.StringIO()
    w = ClemencyFile(io)
    w.write(self._buf)
    v = io.getvalue()
    io.close()
    return v
  def is_printable(self):
    '''
    Returns True if all the characters in the buffer are ASCII printable characters.
    '''
    return all((0 <= c <= 255) for c in self._buf)
  def to_printable_string(self):
    '''
    If this buffer is printable, returns a string version of it. Otherwise fails.
    '''
    assert self.is_printable(), "Buffer %s is not printable" % self._buf
    return ''.join(chr(c) for c in self._buf)
  def __unicode__(self):
    assert False
  @staticmethod
  def from_string(s):
    '''
    To convert an ASCII string into what it would appear like in Clemency memory.
    Note that this does not convert from a standard byte buffer! For that, use
    struct.unpack/struct.pack, or read the data using ClemencyFile.
    '''
    return ClemencyBuffer(map(ord, s))
  def __len__(self):
    return len(self._buf)
  def __iter__(self):
    return self._buf.__iter__()
  def __eq__(self, other):
    if not isinstance(other, type(self)):
      return False
    return other._buf == self._buf
  def __ne__(self, other):
    return not (self == other)
  def ljust(self, nBytes, filler=0):
    assert 0 <= filler <= 0x1ff
    return ClemencyBuffer(self._buf + ([filler] * (nBytes - len(self))))
  def rjust(self, nBytes, filler=0):
    assert 0 <= filler <= 0x1ff
    return ClemencyBuffer(([filler] * (nBytes - len(self))) + self._buf)
  def index(self, buf):
    if isinstance(buf, int):
      return self._buf.index(buf)
    if isinstance(buf, list):
      buf = ClemencyBuffer(buf)
    elif isinstance(buf, str):
      buf = ClemencyBuffer.from_string(buf)
    elif not isinstance(buf, type(self)):
      assert False
    # lol stolen from stackoverflow
    def getsubidx(x, y):
      l1, l2 = len(x), len(y)
      for i in range(l1):
        if x[i:i+l2] == y:
            return i
      return -1
    return getsubidx(self._buf, buf._buf)

CB = ClemencyBuffer

def _write_single(d):
  if d < -0xff or d > 0x1ff:
    raise error("single format requires -0xff <= number <= 0x1ff")
  if d < 0:
    d &= 0x1ff
  return [d]

def _write_word(d):
  if d < -0x1ffff or d > 0x3ffff:
    raise error("word format requires -0x1ffff <= number <= 0x3ffff")
  if d < 0:
    d &= ((1 << 18) - 1)
  bytes = [d & 0x1ff, (d >> 9) & 0x1ff]
  return bytes

def _write_triple(d):
  if d < -0x3ffffff or d > 0x7ffffff:
    raise error("triple format requires -0x3ffffff <= number <= 0x7ffffff")
  if d < 0:
    d &= ((1 << 27) - 1)
  bytes = [(d >> 9) & 0x1ff, (d >> 18) & 0x1ff, d & 0x1ff]
  return bytes

def _write_multi(d):
  if d < -0x1fffffffffffff or d > 0x3fffffffffffff:
    raise error("triple format requires -0x1fffffffffffff <= number <= 0x3fffffffffffff")
  if d < 0:
    d &= ((1 << 54) - 1)
  triples = [(d >> 27) & 0x7ffffff, d & 0x7ffffff]
  res = _write_triple(triples[0])
  res += _write_triple(triples[1])
  return res

def _read_single(pos, data):
  return data[pos], pos + 1

def _read_word(pos, data):
  return (data[pos+1] << 9) | (data[pos]), pos + 2

def _read_triple(pos, data):
  return (data[pos + 1] << 18) | (data[pos] << 9) | data[pos + 2], pos + 3

def _read_multi(pos, data):
  a, p1 = _read_triple(pos, data)
  b, p2 = _read_triple(p1, data)
  return ((a << 27) | b), p2

def _read_single_signed(pos, data):
  single, pos = _read_single(pos, data)
  if single & 0x100 != 0:
    single -= 1
    single ^= 0x1ff
    single = -single
  return single, pos

def _read_word_signed(pos, data):
  single, pos = _read_word(pos, data)
  if single & 0x20000 != 0:
    single -= 1
    single ^= 0x3ffff
    single = -single
  return single, pos

def _read_triple_signed(pos, data):
  single, pos = _read_triple(pos, data)
  if single & 0x4000000 != 0:
    single -= 1
    single ^= 0x7ffffff
    single = -single
  return single, pos

def _read_multi_signed(pos, data):
  multi, pos = _read_multi(pos, data)
  if multi & 0x20000000000000 != 0:
    multi -= 1
    multi ^= 0x3fffffffffffff
    multi = -multi
  return multi, pos

def _parse_format(fmt):
  formatChars = 'swtmSWTM'
  fmtPos = 0
  output = []
  while fmtPos < len(fmt):
    c = fmt[fmtPos]
    if c in formatChars:
      output.append((c, 1))
    elif c in '0123456789':
      num = c
      fmtPos += 1
      while fmt[fmtPos] in '0123456789':
        num += fmt[fmtPos]
        fmtPos += 1
      c = fmt[fmtPos]
      if c not in fmt:
        raise error("bad char in struct format")
      num = int(num)
      output.append((c, num))
    else:
      raise error("bad char in struct format")
    fmtPos += 1
  return output

def pack(fmt, *args):
  '''
  Analogous to Python 2 struct.pack, except that it only supports the following format types:
    S - Clemency byte (9 bits)
    W - Clemency word (18 bits)
    T - Clemency triple (27 bits)
    M - Clemency multi-triple (54 bits)
  All format specifiers support both signed and unsigned operands. Negative operands will be
  transformed via 2's-complement and then fed into the unsigned code.

  You may also use the lowercase versions of the formats, and they will be coerced to uppercase.

  Returns a ClemencyBuffer.

  Example usage:
    >>> struct.pack('M3S', 12107830635004600, 3, 328, 384)
    ClemencyBuffer([64, 344, 64, 1, 0, 184, 3, 328, 384])
  '''
  fmt = _parse_format(fmt)
  if len(args) != sum(z for (c, z) in fmt):
    raise error("pack expected %d items for packing (got %d)" % (sum(z for (c, z) in fmt), len(args)))
  functions = {
    'S': _write_single,
    'W': _write_word,
    'T': _write_triple,
    'M': _write_multi
  }
  buf = ClemencyBuffer([])
  o = []
  for (c, z) in fmt:
    for _ in xrange(z):
      o.append(c)
  for (c, a) in zip(o, args):
    buf += functions[c.upper()](a)
  return buf

def unpack(fmt, s):
  '''
  Analogous to Python 2 struck.unpack, except that it only supports the following format types:
    S - unsigned Clemency byte (9 bits)
    W - unsigned Clemency word (18 bits)
    T - unsigned Clemency triple (27 bits)
    M - unsigned Clemency multi-triple (54 bits)
    s - signed Clemency byte (9 bits)
    w - signed Clemency word (18 bits)
    t - signed Clemency triple (27 bits)
    m - signed Clemency multi-triple (54 bits)
  May take a ClemencyBuffer or a string (eg, obtained directly from the network) as the 2nd arg.

  Example usage:
    >>> struct.unpack('M3S', ' V\x08\x00\x10\x02\xe0\x07H\xc0\x00')
    (12107830635004600, 3, 328, 384)
    >>> struct.unpack('Mt', ClemencyFile(open('hello.bin', 'r')).read(11))
    (12107830635004600, -48232576)
  '''
  total_length = calcsize(fmt)
  if isinstance(s, str):
    io = StringIO.StringIO(s)
    io.seek(0)
    data = ClemencyFile(io).read_all()
  else:
    data = s
  if len(data) != total_length:
    raise error("unpack requires a string argument of %d bits, not %d" % (total_length * 9, len(data) * 9))
  functions = {
    'S': _read_single,
    'W': _read_word,
    'T': _read_triple,
    'M': _read_multi,
    's': _read_single_signed,
    'w': _read_word_signed,
    't': _read_triple_signed,
    'm': _read_multi_signed
  }
  pos = 0
  output = []
  fmt = _parse_format(fmt)
  for (c, z) in fmt:
    for i in xrange(z):
      res, pos = functions[c](pos, data)
      output.append(res)
  return tuple(output)

def calcsize(fmt):
  '''
  Analogous to Python 2 struct.calcsize, given the format types from pack and unpack above.
  '''
  fmt = _parse_format(fmt)
  lengths = {'S': 1, 'W': 2, 'T': 3, 'M': 6}
  total_length = sum((z * lengths[c.upper()]) for (c, z) in fmt)
  return total_length

def p(n):
  '''
  Short-form wrapper around pack('T', n)
  '''
  return pack('T', n)

def u(buf):
  '''
  Short-form wrapper around unpack('T', n)[0]
  '''
  return unpack('T', buf)[0]

def patch_bytes(filename, offset, buf):
  data = ClemencyFile(open(filename, 'r')).read_all()
  for i in xrange(len(buf)):
    data[offset+i] = buf[i]
  ClemencyFile(open(filename, 'w')).write(data)
